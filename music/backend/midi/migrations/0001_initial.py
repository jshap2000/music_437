# Generated by Django 3.1.7 on 2021-03-30 19:02

from django.db import migrations, models
from backend.midi.models import PlayablePiece
from backend.midi.MidiParser import MidiParser
from backend.midi.MidiData import MidiData
from backend.midi.MidiEventDecoder import MidiEventDecoder
import os
import jsonfield.fields


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='PlayablePiece',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=40)),
                ('midi_file', models.FileField(upload_to='playable_midis/')),
                ('time_signature', models.IntegerField(blank=True, null=True)),
                ('time_per_note', models.FloatField(blank=True, null=True)),
                ('notes', jsonfield.fields.JSONField(blank=True, default=list, null=True)),
            ],
        ),
        migrations.CreateModel(
            name='UserPiece',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=40)),
                ('notes', jsonfield.fields.JSONField(blank=True, default=list, null=True)),
            ],
        ),
    ]

    for piece in PlayablePiece.objects.all():
        if piece.time_per_note:
            notes = {}
            midi_file = os.getcwd() + "/media/" + str(piece.midi_file)
            midiData = MidiData(midi_file)
            for i in range(midiData.getNumTracks()):
                track = midiData.getTrack(i)
                for note in track.notes:
                    timing = note.startTime/piece.time_per_note
                    timing = round(timing * 4) / 4
                    if timing not in notes:
                        notes[timing] = [note.pitch]
                    else:
                        notes[timing].append(note.pitch)
            piece.notes = notes# sorted(notes.items(), key = lambda kv: kv[0])
            piece.save()
